\chapter{Metodología}
\label{cap:metodologia}

Las principales herramientas utilizadas en este trabajo han sido las siguientes.

\begin{itemize}
  \item \LaTeX \, como procesador de textos científico.
  \item \emph{Scala} y \emph{Spark} como ecosistema para el tratamiento de datos
  en entornos \emph{Big Data}.
  \item \emph{R} y \emph{ggplot2} para graficar resultados. Junto a \emph{knitr},
  este documento sigue el paradigma de \emph{programación literaria},
  uniendo documento y programa, siendo muy cómodo de escribir y leer.
  \item MariaDB como sistema gestor de bases de datos relacionales (SQL).
\end{itemize}

Se han escogido estas herramientas por ser el estado del arte en cada uno de los
ámbitos para los que fueron desarrolladas. En particular, con \emph{Scala}
y \emph{Spark} se consigue tratamiento de datos en entornos \emph{Big Data} de manera
transparente al usuario, ofreciendo un desarrollo similar en entornos
\unsure{es la palabra más adecuada?}{centralizados} y distribuidos.

\section{Selección de los datos}
\label{sec:seleccion}

Los datos utilizados se han cogido de \citep{DBLP:conf/flairs/RobertsonW14},
que con su trabajo ofrecen seis bases de datos relacionales de partidas dos
contra dos, con las distintas combinaciones de razas que ofrece el juego.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figure/Robertson14DatabaseDiagram.pdf}
  \caption{Diagrama Entidad-Relación que modela cada una de las bases de datos.}
  \label{fig:database}
\end{figure}

En la figura~\ref{fig:database} se puede ver el diagrama Entidad-Relación de
las bases de datos que contienen las partidas. En primer lugar hay que
comprender los datos que se tienen para saber de qué conocimiento se parte.
Este paso ha sido sencillo gracias a lo dicho en el capítulo~\ref{cap:objetivos},
el que el trabajo de \citep{DBLP:conf/flairs/RobertsonW14} sea libre facilita
mucho esta tarea. La mayoría de características comparten nombre con atributos
propios del juego extraídos de la API más utilizada para trabajar con
\emph{StarCraft}, la \fnurl{\emph{BWAPI}}{http://bwapi.github.io/}. Otros datos
son derivados que han calculado los investigadores, como la distancia a la base
en un determinado momento.

En siguiente lugar, hay que ver
qué variables se cogen y cómo se organizan. El objetivo de este
paso es conseguir una tabla de la forma filas por columnas, de manera que pueda
ser interpretable por cualquier algoritmo clásico de aprendizaje.

La propuesta es la siguiente: cada fila del conjunto de datos va a ser un
instante de la partida, que estará compuesto por los recursos de cada jugador.
Es un enfoque distinto a la mayoría de los que se trabajan, como se ha comentado
en el capítulo~\ref{cap:introduccion}.
A primera vista parece sencillo, pero se verá que conseguir información sobre
las unidades de cada jugador no va a ser tarea fácil.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figure/Robertson14DatabaseDiagramSeleccion.pdf}
  \caption{Variables seleccionadas de las bases de datos.}
  \label{fig:databaseSelection}
\end{figure}

En la figura~\ref{fig:databaseSelection} ve pueden ver las variables
seleccionadas, que se explican en las siguientes líneas. Posteriormente se
procederá a explicar cómo se han extraído dichas características.

Las características seleccionadas son, principalmente, los recursos de cada
jugador, sus unidades (que se cuantifican no según el número sino según la
suma de unos determinados valores que tiene cada unidad, dependiendo de su
importancia) y sus edificios, además de las observaciones de estos valores que
tiene un jugador del otro. Por último, también se tienen en cuenta el valor
que cada jugador cree que queda de los recursos del mapa.

Los detalles de las características seleccionadas según cada tabla son:

\begin{itemize}
  \item replay: Esta tabla contiene datos asociados a cada partida.
  \begin{itemize}
    \item ReplayID: Identificador de cada partida.
    \item Duration: Duración (en frames) de cada partida. 15 frames equivalen a 1 segundo.
  \end{itemize}
  \item playerreplay: Esta tabla contiene datos asociados a un jugador en una partida.
  \begin{itemize}
    \item PlayerReplayID: Identificador de un jugador en una partida.
    \item ReplayID: Identificador de partida asociado.
    \item Winner: Ganador de cada partida.
  \end{itemize}
  \item resourcechange: Esta tabla contiene datos asociados a cambios en los recursos de un jugador.
  \begin{itemize}
    \item PlayerReplayID: Identificador del jugador que produce un cambio.
    \item Frame: Frame en el que se produce un cambio.
    \item Minerals: Cantidad de minerales que tiene un jugador en ese momento.
    \item Gas: Cantidad de gas que tiene un jugador en ese momento.
    \item Supply: Capacidad de carga del jugador.
    \item TotalMinerals: Cantidad total de minerales que ha obtenido un jugador, sin contar gastos.
    \item TotalGas: Cantidad total de gas que ha obtenido un jugador, sin contar gastos.
    \item TotalSupply: Capacidad que ha obtenido un jugador, sin contar gastos.
  \end{itemize}
  \item regionvaluechange: Esta tabla contiene datos asociados a cambios de un jugador
  en una región del mapa determinada. Cada \emph{value}, que llamaremos de aquí en adelante
  \emph{valor}, es la suma del precio de una unidad en Minerales y Gas.
  \begin{itemize}
    \item PlayerReplayID: Identificador del jugador que produce un cambio.
    \item RegionID: Identificador de la región del mapa donde se produce un cambio.
    \item Frame: Frame en el que se produce el cambio.
    \item GroundUnitValue: Valor de las unidades terrestres en esta región.
    \item BuildingValue: Valor de las construcciones en esta región.
    \item AirUnitValue: Valor de las unidades aéreas en esta región.
    \item EnemyGroundUnitValue: Valor de las unidades terrestres del enemigo en esta región.
    Este valor es estimado, sólo se conoce lo que el jugador puede ver del enemigo.
    \item EnemyBuildingValue: Valor de las construcciones del enemigo en esta región.
    Este valor es estimado, sólo se conoce lo que el jugador puede ver del enemigo.
    \item EnemyAirUnitValue: Valor de las unidades aéreas del enemigo en esta región.
    Este valor es estimado, sólo se conoce lo que el jugador puede ver del enemigo.
    \item ResourceValue: Valor de los recursos en esta región. Este valor es estimado,
    sólo se conoce lo que el jugador puede ver del mapa. Si el jugador no conoce una zona, estima que los recursos restantes es la totalidad de lo disponible en la región.
  \end{itemize}
\end{itemize}

Una vez decididas las variables que vamos a tomar, se pasará a manejar las
bases de datos para conseguirlas de la manera más limpia posible.

\section{Preprocesamiento y transformación de los datos}
\label{sec:preprocesamiento}

Como se ha comentado anteriormente, los datos vienen organizados en seis bases
de datos relacionales, de tipo SQL, por lo que se hace necesario el uso de un
\emph{Sistema Gestor de Bases de Datos}. Como se comentó al principio de esta
sección, se ha elegido \emph{MariaDB} por ser la implementación libre de la
archiconocida \emph{MySQL}. \unsure{Si hay tiempo, ¿por qué no?}{No} se detallará
el montaje y puesta en marcha de esto, aunque es de gran importancia
hacer saber que para cualquier científico de datos, manejarse con el
levantamiento de este tipo de servicios también es muy importante.

El procedimiento para extraer las partidas no es más que una consulta para cada
partida de la base de datos. Esta consulta es algo compleja, por lo que se
intentará explicar de la manera más clara posible.

Lo primero será concentrarse en una partida: después se iterará sobre todas
con un procedimiento. Se podría haber resuelto todo con una sola consulta, pero
habría complicado un poco más su escritura y depuración. Una vez tenemos un
\emph{ReplayID} en concreto, se toma su duración \emph{Duration} y los
jugadores que compiten en ella \emph{PlayerReplayID}. Se tomará como el primero
el que tenga un \emph{PlayerReplayID} más pequeño, aunque se verá más adelante
que no habrá ninguna ventaja para ningún jugador.

Ahora hay que tomar una decisión importante. Tras un primer vistazo a los datos,
se observa que los instantes de tiempo \emph{Frame} en los que se registra
algún cambio no tienen por qué ser ni siquiera
parecidos, ni entre jugadores ni entre cambios de unidades o recursos.
Por tanto, se procede de la siguiente manera: para no perjudicar a ninguno de
los jugadores, en el conjunto de datos final los instantes de tiempo tomados
como referencia serán aquellos instantes en los que exista un cambio en los
recursos, que no unidades, de cada uno de los dos jugadores.

Esto implica directamente otra pequeña decisión al diseñar la consulta. Como
se ha comentado, los instantes de tiempo de los cambios en las unidades de
un jugador no tienen por qué coincidir con los cambios en recursos (es más,
es muy poco probable que coincidan exactamente). Por lo tanto, al tomar como
referencia los instantes de tiempo \emph{Frame} de cambios de recursos, hay
que buscar la manera de tomar el estado actual de las unidades de cada jugador
más precisa posible en el instante determinado. Esto se soluciona fácilmente
tomando el último valor de las unidades en el tiempo: se tomará el valor de
las unidades en el instante de tiempo más grande posible, pero más pequeño
que el actual.

Una vez se tienen las referencias en tl tiempo, falta un detalle importante:
como se ha comentado en la sección~\ref{sec:seleccion}, los cambios registrados
en los valores de las unidades son a nivel de una determinada región del mapa.
Por tanto, para tomar el valor total de las unidades de un jugador, hay que
sumar los valores en todas las regiones del mapa.

Además de todo esto, existe una última cuestión que se ha tenido que resolver.
Al tomar datos de un jugador en un instante de tiempo para el que dicho jugador
no tiene información, dichos datos desconocidos se rellenan con \texttt{NULL}.
Sería sencillo dejarlos así y en una siguiente fase, imputar dichos datos
perdidos con cualquier algoritmo clásico. Pero existe una solución mejor y
mucho más lógica para este problema: si para un jugador, un dato no existe
porque no ha habido un cambio en ese instante de tiempo, significa que tendrá
los mismos recursos/unidades/etc que en su anterior cambio. Por tanto, sólo
hay que tomar el valor no nulo anterior más próximo para cada una de las
variables de la tabla.

Una vez con todos los datos bien formados, sólo hay que añadir el
\emph{ReplayID}, la duración de la partida \emph{Duration}, el ganador
\emph{Winner} y las razas implicadas. De esta manera ya tenemos todos los
datos de una partida bien formados, sin valores perdidos y listos para ser
tratados como un conjunto de datos sobre cualquier software. Como se ha
comentado anteriormente, sólo hay que iterar por los distintos \emph{ReplayID}
para conseguir los datos de todas las partidas de cada una de las seis bases
de datos.



\section{Modelado}
\label{sec:modelado}
